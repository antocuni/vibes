<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wasi-posix-sockets</title>
    <style>:root {
    --color-bg: #ffffff;
    --color-text: #24292f;
    --color-link: #0969da;
    --color-border: #d0d7de;
    --color-code-bg: #f6f8fa;
    --color-header-bg: #f6f8fa;
    --color-app-btn: #2da44e;
    --color-app-btn-hover: #218838;
}

* { box-sizing: border-box; }

body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Noto, Helvetica, Arial, sans-serif;
    line-height: 1.6;
    color: var(--color-text);
    background: var(--color-bg);
    margin: 0;
    padding: 0;
}

.container {
    max-width: 800px;
    margin: 0 auto;
    padding: 2rem 1.5rem;
}

nav {
    margin-bottom: 2rem;
    padding-bottom: 1rem;
    border-bottom: 1px solid var(--color-border);
    font-size: 0.9rem;
}

nav a {
    color: var(--color-link);
    text-decoration: none;
}

nav a:hover {
    text-decoration: underline;
}

article h1 { font-size: 2rem; border-bottom: 1px solid var(--color-border); padding-bottom: 0.3em; }
article h2 { font-size: 1.5rem; border-bottom: 1px solid var(--color-border); padding-bottom: 0.3em; margin-top: 1.5em; }
article h3 { font-size: 1.25rem; margin-top: 1.5em; }

a { color: var(--color-link); text-decoration: none; }
a:hover { text-decoration: underline; }

code {
    background: var(--color-code-bg);
    padding: 0.2em 0.4em;
    border-radius: 6px;
    font-size: 0.85em;
    font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, Consolas, "Liberation Mono", monospace;
}

pre {
    background: var(--color-code-bg);
    padding: 1rem;
    border-radius: 6px;
    overflow-x: auto;
    line-height: 1.45;
}

pre code {
    background: none;
    padding: 0;
    border-radius: 0;
    font-size: 0.85em;
}

ul, ol { padding-left: 2em; }
li { margin: 0.25em 0; }

hr {
    border: none;
    border-top: 1px solid var(--color-border);
    margin: 2rem 0;
}

table {
    border-collapse: collapse;
    width: 100%;
}

th, td {
    border: 1px solid var(--color-border);
    padding: 0.5em 1em;
    text-align: left;
}

th {
    background: var(--color-header-bg);
}

.app-link {
    display: inline-block;
    margin: 1rem 0;
    padding: 0.6rem 1.2rem;
    background: var(--color-app-btn);
    color: #fff;
    border-radius: 6px;
    font-weight: 600;
    text-decoration: none;
    font-size: 1rem;
}

.app-link:hover {
    background: var(--color-app-btn-hover);
    text-decoration: none;
}

.project-list a {
    font-weight: 600;
}

footer {
    margin-top: 3rem;
    padding-top: 1rem;
    border-top: 1px solid var(--color-border);
    font-size: 0.8rem;
    color: #656d76;
}
</style>
    
</head>
<body>
    <div class="container">
        <nav><a href="../">← Back to all projects</a></nav>
        <article>
<h1 id="wasi-posix-sockets-demo">WASI POSIX Sockets Demo</h1>
<p>POSIX socket functions (socket, connect, send, recv, bind, listen, accept, close)
exposed as WASM imports, with a Python/wasmtime host providing the real implementations.</p>
<h2 id="what-was-explored">What was explored</h2>
<p>WASI doesn't include socket support in its standard preview1 API. This project demonstrates
how to bridge that gap: C programs compiled to WASM declare socket functions as imports
(using <code>__attribute__((import_module(...)))</code>) and a Python host using the <code>wasmtime</code> library
fulfills those imports by delegating to real Python <code>socket</code> operations.</p>
<p>This approach lets C code use a familiar POSIX-like socket API while running inside a WASM
sandbox, with the host controlling all network access.</p>
<h2 id="architecture">Architecture</h2>
<pre class="highlight"><code>┌─────────────────────────────────────────────────┐
│  C program (compiled to WASM)                   │
│  ┌───────────────────────────────────────────┐  │
│  │  http_client.c / echo_server.c            │  │
│  │  calls: wasm_sock_socket(), connect(), ...│  │
│  └──────────────────┬────────────────────────┘  │
│                     │ WASM imports               │
│                     │ (posix_sockets module)     │
├─────────────────────┼───────────────────────────┤
│  Python host        │                           │
│  ┌──────────────────▼────────────────────────┐  │
│  │  run_wasm.py                              │  │
│  │  SocketShim class                         │  │
│  │  - manages fd -&gt; socket.socket table      │  │
│  │  - reads/writes WASM linear memory        │  │
│  │  - translates sockaddr structs            │  │
│  └──────────────────┬────────────────────────┘  │
│                     │ real Python sockets        │
│                     ▼                            │
│               Operating System                   │
└─────────────────────────────────────────────────┘
</code></pre>

<h2 id="files">Files</h2>
<table>
<thead>
<tr>
<th>File</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>posix_sockets.h</code></td>
<td>C header declaring socket functions as WASM imports</td>
</tr>
<tr>
<td><code>http_client.c</code></td>
<td>HTTP client demo - fetches a URL via raw sockets</td>
</tr>
<tr>
<td><code>echo_server.c</code></td>
<td>TCP echo server demo - accepts one connection, echoes data</td>
</tr>
<tr>
<td><code>run_wasm.py</code></td>
<td>Python host that loads WASM and provides socket imports</td>
</tr>
<tr>
<td><code>test_demo.py</code></td>
<td>End-to-end tests for all demos</td>
</tr>
<tr>
<td><code>libcurl-wasm/</code></td>
<td>libcurl-compatible API implemented on top of the socket shims</td>
</tr>
</tbody>
</table>
<h2 id="implementation">Implementation</h2>
<h3 id="the-shim-header-posix_socketsh">The shim header (<code>posix_sockets.h</code>)</h3>
<p>Socket functions are declared with GCC/Clang attributes that control WASM import generation:</p>
<pre class="highlight"><code class="language-c">__attribute__((import_module(&quot;posix_sockets&quot;), import_name(&quot;socket&quot;)))
int wasm_sock_socket(int domain, int type, int protocol);
</code></pre>

<p>This tells the WASM linker: "this function is imported from module <code>posix_sockets</code>, name <code>socket</code>".
The C-side function name (<code>wasm_sock_socket</code>) avoids collisions with wasi-libc symbols.</p>
<h3 id="the-python-host-run_wasmpy">The Python host (<code>run_wasm.py</code>)</h3>
<p>The <code>SocketShim</code> class maintains a table mapping integer file descriptors to Python <code>socket.socket</code>
objects. Each imported function:</p>
<ol>
<li>Receives WASM i32 arguments (fd numbers, memory pointers, lengths)</li>
<li>Reads data from WASM linear memory when needed (e.g., sockaddr structs, send buffers)</li>
<li>Calls the corresponding Python socket method</li>
<li>Writes results back to WASM memory when needed (e.g., recv buffers)</li>
<li>Returns an i32 result code</li>
</ol>
<p>The host uses <code>wasmtime.Linker.define_func()</code> with <code>access_caller=True</code> to get a <code>Caller</code>
object that provides access to the WASM module's exported memory.</p>
<h3 id="libcurl-compatible-demo-libcurl-wasm">libcurl-compatible demo (<code>libcurl-wasm/</code>)</h3>
<p>A minimal implementation of the libcurl easy API (<code>curl_easy_init</code>, <code>curl_easy_setopt</code>,
<code>curl_easy_perform</code>, <code>curl_easy_cleanup</code>) built on top of the socket shims. Demonstrates
that higher-level networking APIs can work in WASM using this approach.</p>
<h2 id="key-findings">Key findings</h2>
<ul>
<li>WASM <code>import_module</code>/<code>import_name</code> attributes work well for creating clean import boundaries</li>
<li>The host needs to handle byte order carefully: <code>sin_port</code> is stored in network (big-endian)
  order by the C code, but WASM is little-endian for struct field access</li>
<li>wasi-libc provides stdio (printf, etc.) which works alongside custom socket imports</li>
<li>The <code>Caller</code> API in wasmtime-py provides convenient access to WASM linear memory</li>
<li>Function names in C must avoid colliding with wasi-libc symbols (e.g., <code>posix_close</code> exists
  in wasi-libc, so we use <code>wasm_sock_close</code> instead)</li>
</ul>
<h2 id="usage">Usage</h2>
<h3 id="prerequisites">Prerequisites</h3>
<pre class="highlight"><code class="language-bash">apt install wasi-libc libclang-rt-18-dev-wasm32 clang lld
pip install wasmtime
</code></pre>

<h3 id="build">Build</h3>
<pre class="highlight"><code class="language-bash">make                          # builds http_client.wasm and echo_server.wasm
cd libcurl-wasm &amp;&amp; make       # builds curl_demo.wasm
</code></pre>

<h3 id="run-demos">Run demos</h3>
<pre class="highlight"><code class="language-bash"># HTTP client (needs a server at the given IP:port)
python3 run_wasm.py http_client.wasm 93.184.215.14 80 /

# Echo server (listens on port 8080)
python3 run_wasm.py echo_server.wasm 8080

# curl demo (needs a server at the given URL - IP addresses only, no DNS)
python3 run_wasm.py libcurl-wasm/curl_demo.wasm http://127.0.0.1:8080/
</code></pre>

<h3 id="run-tests">Run tests</h3>
<pre class="highlight"><code class="language-bash">python3 test_demo.py
</code></pre>

<p>The tests start local TCP servers and verify the WASM modules work end-to-end.</p>
<h2 id="limitations">Limitations</h2>
<ul>
<li><strong>No DNS</strong>: WASM modules must use IP addresses directly (the host could add a
  <code>gethostbyname</code> import to fix this)</li>
<li><strong>IPv4 only</strong>: Only <code>AF_INET</code> is implemented</li>
<li><strong>HTTP/1.0 only</strong>: The curl shim uses <code>Connection: close</code> semantics</li>
<li><strong>No TLS</strong>: Would need an additional shim layer for SSL/TLS</li>
<li><strong>Single-threaded</strong>: The echo server handles one connection at a time</li>
</ul>
        </article>
        <footer>
            Built automatically from project README files.
        </footer>
    </div>
</body>
</html>